json raylib: g++ main.cpp -o programa.exe -I"C:\raylib\include" -L"C:\raylib\lib" -lraylib -lopengl32 -lgdi32 -lwinmm

ruta: cd /c/Users/saezi/Desktop/Proyecto

main v1:
#include <raylib.h>
#include <string>
#include <iostream>
#include <vector>
using namespace std;

// ===============================
//  PROTOTIPOS
// ===============================
void pantallaSumarRestar();
void pantallaMultiplicar();
void pantallaDividir();
void pantallaFactorial();
void pantallaFibonacci();
void pantallaNumeroPrimo();
void pantallaParImpar();
void pantallaPotencia();
void pantallaProbabilidad();
void pantallaDistanciaPlanetas();


// Opciones del menÃº
const char *menuItems[] = {
    "1) Sumar / Restar",
    "2) Multiplicar",
    "3) Dividir",
    "4) Factorial",
    "5) Fibonacci",
    "6) Numero primo",
    "7) Par o Impar",
    "8) Potencia",
    "9) Probabilidad",
    "10) Distancia planetas",
    "11) Salir"
};

int menuCount = 11;

int main() {

    // Crear ventana
    InitWindow(800, 600, "Calculadora Moya - Raylib");
    SetTargetFPS(60);

    string nombreUsuario = "";
    bool nombreIngresado = false;

    while (!WindowShouldClose()) {

        BeginDrawing();
        ClearBackground(RAYWHITE);

        // ==========================
        //  PANTALLA INGRESAR NOMBRE
        // ==========================
        if (!nombreIngresado) {

            DrawText("Bienvenido!", 340, 80, 30, DARKBLUE);
            DrawText("Ingresa tu nombre y presiona ENTER:", 180, 200, 20, BLACK);

            DrawRectangle(180, 250, 450, 40, LIGHTGRAY);
            DrawText(nombreUsuario.c_str(), 190, 260, 20, BLACK);

            int key = GetCharPressed();
            while (key > 0) {
                if (key >= 32 && key <= 125) {
                    nombreUsuario.push_back((char)key);
                }
                key = GetCharPressed();
            }
            if (IsKeyPressed(KEY_BACKSPACE) && nombreUsuario.length() > 0) {
                nombreUsuario.pop_back();
            }
            if (IsKeyPressed(KEY_ENTER) && nombreUsuario.length() > 0) {
                nombreIngresado = true;
            }
        }

        // ==========================
        //  MENÃš PRINCIPAL
        // ==========================
        else {

            string saludo = "Hola, " + nombreUsuario + "! Selecciona una opcion:";
            DrawText(saludo.c_str(), 200, 50, 25, DARKGREEN);

            int startY = 120;
            for (int i = 0; i < menuCount; i++) {
                DrawText(menuItems[i], 280, startY + (i * 35), 20, BLACK);
            }

            DrawText("Presiona una tecla del 1 al 11", 250, 560, 20, GRAY);

            // DETECTAR OPCIÃ“N
            if (IsKeyPressed(KEY_ONE))      pantallaSumarRestar();
            if (IsKeyPressed(KEY_TWO))      pantallaMultiplicar();
            if (IsKeyPressed(KEY_THREE))    pantallaDividir();
            if (IsKeyPressed(KEY_FOUR))     pantallaFactorial();
            if (IsKeyPressed(KEY_FIVE))     pantallaFibonacci();
            if (IsKeyPressed(KEY_SIX))      pantallaNumeroPrimo();
            if (IsKeyPressed(KEY_SEVEN))    pantallaParImpar();
            if (IsKeyPressed(KEY_EIGHT))    pantallaPotencia();
            if (IsKeyPressed(KEY_NINE))     pantallaProbabilidad();
            if (IsKeyPressed(KEY_ZERO))     pantallaDistanciaPlanetas();   // TEMPORAL (10)
            if (IsKeyPressed(KEY_MINUS))    CloseWindow();                 // TEMPORAL (11)

        }

        EndDrawing();
    }

    CloseWindow();
    return 0;
}


// =====================================
//   FUNCIONES DE CADA OPCIÃ“N
//   (Pantallas independientes)
// =====================================

void pantallaSumarRestar() {

    string numeroActual = "";
    string numero1 = "";
    string numero2 = "";
    bool ingresandoPrimero = true;
    bool resultadoListo = false;
    float resultado = 0;

    vector<string> historial;

    while (!IsKeyPressed(KEY_BACKSPACE) && !WindowShouldClose()) {

        // Entrada de dÃ­gitos
        int key = GetCharPressed();
        while (key > 0) {
            if (key >= '0' && key <= '9') {
                numeroActual.push_back((char)key);
            }
            key = GetCharPressed();
        }

        // Borrar un dÃ­gito
        if (IsKeyPressed(KEY_BACKSPACE) && numeroActual.length() > 0) {
            numeroActual.pop_back();
        }

        // Cuando el usuario presiona ENTER, confirma nÃºmero
        if (IsKeyPressed(KEY_ENTER) && numeroActual.length() > 0) {

            if (ingresandoPrimero) {
                numero1 = numeroActual;
                numeroActual = "";
                ingresandoPrimero = false;
            } else {
                numero2 = numeroActual;
                numeroActual = "";
                resultadoListo = false;
            }
        }

        // SUMAR â†’ tecla S
        if (IsKeyPressed(KEY_S) && numero1 != "" && numero2 != "") {
            resultado = stof(numero1) + stof(numero2);
            resultadoListo = true;
            historial.push_back(numero1 + " + " + numero2 + " = " + to_string(resultado));
        }

        // RESTAR â†’ tecla R
        if (IsKeyPressed(KEY_R) && numero1 != "" && numero2 != "") {
            resultado = stof(numero1) - stof(numero2);
            resultadoListo = true;
            historial.push_back(numero1 + " - " + numero2 + " = " + to_string(resultado));
        }

        // ===================== DIBUJO =====================
        BeginDrawing();
        ClearBackground(LIGHTGRAY);

        DrawText("SUMAR / RESTAR", 260, 20, 30, BLUE);
        DrawText("BACKSPACE = volver al menu", 10, 560, 20, RED);

        if (ingresandoPrimero)
            DrawText("Ingresa PRIMER numero:", 50, 100, 20, BLACK);
        else
            DrawText("Ingresa SEGUNDO numero:", 50, 100, 20, BLACK);

        DrawText(numeroActual.c_str(), 50, 140, 30, DARKBLUE);

        if (numero1 != "")
            DrawText(("Numero 1: " + numero1).c_str(), 50, 200, 20, BLACK);
        if (numero2 != "")
            DrawText(("Numero 2: " + numero2).c_str(), 50, 230, 20, BLACK);

        DrawText("S = Sumar   |   R = Restar   |   ENTER = Confirmar numero", 50, 300, 20, DARKGRAY);

        if (resultadoListo) {
            DrawText(("RESULTADO: " + to_string(resultado)).c_str(), 50, 350, 28, RED);
        }

        // HISTORIAL
        DrawText("Historial:", 500, 100, 22, BLACK);
        int y = 130;
        for (int i = max(0, (int)historial.size() - 10); i < historial.size(); i++) {
            DrawText(historial[i].c_str(), 500, y, 18, DARKGREEN);
            y += 22;
        }

        EndDrawing();
    }
}


void pantallaMultiplicar() {
    while (!IsKeyPressed(KEY_BACKSPACE) && !WindowShouldClose()) {
        BeginDrawing();
        ClearBackground(LIGHTGRAY);
        DrawText("Pantalla: MULTIPLICAR", 200, 200, 30, BLUE);
        DrawText("Presiona BACKSPACE para volver", 200, 300, 20, RED);
        EndDrawing();
    }
}

void pantallaDividir() {
    while (!IsKeyPressed(KEY_BACKSPACE) && !WindowShouldClose()) {
        BeginDrawing();
        ClearBackground(LIGHTGRAY);
        DrawText("Pantalla: DIVIDIR", 200, 200, 30, BLUE);
        DrawText("Presiona BACKSPACE para volver", 200, 300, 20, RED);
        EndDrawing();
    }
}

void pantallaFactorial() {
    while (!IsKeyPressed(KEY_BACKSPACE) && !WindowShouldClose()) {
        BeginDrawing();
        ClearBackground(LIGHTGRAY);
        DrawText("Pantalla: FACTORIAL", 200, 200, 30, BLUE);
        DrawText("Presiona BACKSPACE para volver", 200, 300, 20, RED);
        EndDrawing();
    }
}

void pantallaFibonacci() {
    while (!IsKeyPressed(KEY_BACKSPACE) && !WindowShouldClose()) {
        BeginDrawing();
        ClearBackground(LIGHTGRAY);
        DrawText("Pantalla: FIBONACCI", 200, 200, 30, BLUE);
        DrawText("Presiona BACKSPACE para volver", 200, 300, 20, RED);
        EndDrawing();
    }
}

void pantallaNumeroPrimo() {
    while (!IsKeyPressed(KEY_BACKSPACE) && !WindowShouldClose()) {
        BeginDrawing();
        ClearBackground(LIGHTGRAY);
        DrawText("Pantalla: NUMERO PRIMO", 200, 200, 30, BLUE);
        DrawText("Presiona BACKSPACE para volver", 200, 300, 20, RED);
        EndDrawing();
    }
}

void pantallaParImpar() {
    while (!IsKeyPressed(KEY_BACKSPACE) && !WindowShouldClose()) {
        BeginDrawing();
        ClearBackground(LIGHTGRAY);
        DrawText("Pantalla: PAR / IMPAR", 200, 200, 30, BLUE);
        DrawText("Presiona BACKSPACE para volver", 200, 300, 20, RED);
        EndDrawing();
    }
}

void pantallaPotencia() {
    while (!IsKeyPressed(KEY_BACKSPACE) && !WindowShouldClose()) {
        BeginDrawing();
        ClearBackground(LIGHTGRAY);
        DrawText("Pantalla: POTENCIA", 200, 200, 30, BLUE);
        DrawText("Presiona BACKSPACE para volver", 200, 300, 20, RED);
        EndDrawing();
    }
}

void pantallaProbabilidad() {
    while (!IsKeyPressed(KEY_BACKSPACE) && !WindowShouldClose()) {
        BeginDrawing();
        ClearBackground(LIGHTGRAY);
        DrawText("Pantalla: PROBABILIDAD", 200, 200, 30, BLUE);
        DrawText("Presiona BACKSPACE para volver", 200, 300, 20, RED);
        EndDrawing();
    }
}

void pantallaDistanciaPlanetas() {
    while (!IsKeyPressed(KEY_BACKSPACE) && !WindowShouldClose()) {
        BeginDrawing();
        ClearBackground(LIGHTGRAY);
        DrawText("Pantalla: DISTANCIA PLANETAS", 200, 200, 30, BLUE);
        DrawText("Presiona BACKSPACE para volver", 200, 300, 20, RED);
        EndDrawing();
    }
}




Efecto â€œBreak / Click Feedbackâ€

Idea: Cuando se haga clic en un botÃ³n, el botÃ³n podrÃ­a â€œromperseâ€, oscurecerse o parpadear por un instante.

âœ… Por quÃ© es Ãºtil:

Mejora la respuesta visual

Le da sensaciÃ³n de interacciÃ³n real

âœ… CÃ³mo hacerlo:

Cambiar el color del botÃ³n durante unos frames al hacer clic.

ðŸ”¹ 2) AnimaciÃ³n de botones al pasar el mouse

Idea: AÃ±adir efectos:

Escala (agrandarse 4â€“10%)

Glow (resplandor)

Bordes dinÃ¡micos

Sombras suaves

âœ… Por quÃ©:

Hace que la UI sea mÃ¡s agradable y moderna.

ðŸ”¹ 3) Fondo animado mejorado

Lo actual estÃ¡ bien, pero podrÃ­as aÃ±adir:

âœ¨ Ideas:

Degradientes en movimiento

PartÃ­culas dinÃ¡micas siguiendo el mouse

Ondas suaves

LÃ­neas geomÃ©tricas rotando

Efecto â€œespacio / galaxiaâ€

âœ… Por quÃ©:

MÃ¡s atractivo

SensaciÃ³n viva

Mantiene la interfaz moderna

ðŸ”¹ 4) Tema de colores ampliado

Ahora usas azules y verdes principalmente.
Puedes agregar:

ðŸŽ¨ Paleta propuesta:

Morado â†’ para botones secundarios

Naranja â†’ advertencias

Verde â†’ confirmaciones

Amarillo â†’ cÃ¡lculos recientes

Degradientes entre tonos

âœ… Por quÃ©:

MÃ¡s contraste

MÃ¡s personalidad

ðŸ”¹ 5) Transiciones entre pantallas

Ej.:

Fade in/out

Slide horizontal

Zoom sobre el frame

âœ… Por quÃ©:
Mejora fluidez visual, mÃ¡s profesional.

ðŸ”¹ 6) Sonidos SFX

Click de botones

Al completar una operaciÃ³n

Error al dividir entre cero

Sonido suave al abrir un menÃº

âœ… Por quÃ©:
Aumenta la percepciÃ³n de interacciÃ³n fÃ­sica.

ðŸ”¹ 7) Historial mejorado

Actualmente solo imprime texto.
PodrÃ­as agregar:

ðŸ“Œ Ideas:

Scroll (si hay muchos datos)

BotÃ³n de limpiar historial

.

ðŸ”¹ 8) Agregar modo oscuro

Switch que invierta los colores principales.
BG â†’ negro
Texto â†’ blanco
Botones â†’ tonos brillantes

âœ… Por quÃ©:

Menos fatiga visual

Se siente mÃ¡s moderno

ðŸ”¹ 9) ValidaciÃ³n visual de errores

Ejemplo: divisiÃ³n entre cero â†’ pantalla roja con un icono âš ï¸

âœ… Por quÃ©:
Comunica mejor el problema.

ðŸ”¹ 10) TipografÃ­as personalizadas

Temas:

Futurista

MatemÃ¡tica

Elegante

âœ… Por quÃ©:
Define identidad visual.

ðŸ”¹ 11) Efecto de rebote al abrir teclado numÃ©rico

Ej.:
Cuando aparece el teclado numÃ©rico, que estÃ©:

Escalado 0.7

Bounce-in â†’ escala hasta 1.0

âœ… Por quÃ©:
MÃ¡s dinÃ¡mico, mÃ¡s â€œapp modernaâ€.

ðŸ”¹ 12) Ingreso mixto (Teclado + Mouse)

Ahora solo numpad visual â†’ permitir:

Teclado real nÃºmero

Delete por tecla real

Enter â†’ confirmar

âœ… Por quÃ©:
MÃ¡s rÃ¡pido para usuarios reales.

ðŸ”¹ 13) Fade visual en datos calculados

Cuando aparece el resultado:

Texto entra con fade o con â€œtyping animationâ€

âœ… Por quÃ©:
MÃ¡s suave y satisfactorio.

ðŸ”¹ 14) AÃ±adir mÃ¡s operaciones

Logaritmos

RaÃ­z cuadrada / n

TrigonometrÃ­a

ConversiÃ³n unidades

âœ… Por quÃ©:
MÃ¡s completa.

ðŸ”¹ 15) DiseÃ±o adaptable (resizable)

Si cambias tamaÃ±o de ventana â†’ la UI se reajusta.

âœ… Por quÃ©:
MÃ¡s accesible en diferentes pantallas.

ðŸ”¹ 16) Icono cargado desde archivo

En lugar del Ã­cono por defecto, asignar uno propio.

âœ… Por quÃ©:
Identidad visual.

ðŸ”¹ 17) AnimaciÃ³n mÃ­nima de â€œidleâ€

Si usuario no hace nada:

Los botones brillan

Fondo â€œrespiraâ€

âœ… Por quÃ©:
Da vida a la interfaz.
